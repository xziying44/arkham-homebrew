<template>
  <div class="deck-builder-container">
    <div class="deck-builder-header">
      <h2>üÉè ÁâåÂ∫ìÂà∂‰Ωú</h2>
      <div class="header-actions">
        <n-button type="primary" @click="showCreateDeckDialog = true" size="large">
          <template #icon>
            <n-icon :component="AddOutline" />
          </template>
          Êñ∞Âª∫ÁâåÂ∫ì
        </n-button>
      </div>
    </div>

    <div class="deck-builder-content">
      <!-- Â∑¶‰æßÁâåÂ∫ìÂàóË°® -->
      <div class="deck-list-panel">
        <div class="panel-header">
          <h3>ÊàëÁöÑÁâåÂ∫ì</h3>
          <n-button text @click="loadDecks" :loading="loading" title="Âà∑Êñ∞">
            <n-icon :component="RefreshOutline" />
          </n-button>
        </div>
        <n-scrollbar class="deck-list">
          <div v-for="deck in deckList" :key="deck.path" class="deck-item"
            :class="{ 'active': selectedDeck?.path === deck.path }" @click="selectDeck(deck)">
            <div class="deck-icon">üé¥</div>
            <div class="deck-info">
              <div class="deck-name">{{ deck.name }}</div>
              <div class="deck-meta">{{ deck.width }}√ó{{ deck.height }} ÁΩëÊ†º</div>
            </div>
            <n-button text type="error" @click.stop="showDeleteConfirm(deck)" title="Âà†Èô§ÁâåÂ∫ì" size="small">
              <n-icon :component="TrashOutline" />
            </n-button>
          </div>
          <n-empty v-if="deckList.length === 0 && !loading" description="ÊöÇÊó†ÁâåÂ∫ì">
            <template #icon>
              <n-icon :component="FolderOpenOutline" />
            </template>
            <template #extra>
              <n-text depth="3">ÁÇπÂáª‰∏äÊñπÊåâÈíÆÂàõÂª∫Êñ∞ÁâåÂ∫ì</n-text>
            </template>
          </n-empty>
        </n-scrollbar>
      </div>

      <!-- ‰∏≠Èó¥ÁâåÂ∫ìÁºñËæëÂå∫ -->
      <div class="deck-editor-panel" v-if="selectedDeck">
        <div class="panel-header">
          <h3>{{ selectedDeck.name }}</h3>
          <div class="editor-actions">
            <!-- ÊòæËëóÁöÑ‰øùÂ≠òÊåâÈíÆ -->
            <n-button type="primary" @click="saveDeck" :loading="saving" size="large" class="save-button">
              <template #icon>
                <n-icon :component="SaveOutline" />
              </template>
              ‰øùÂ≠òÁâåÂ∫ì
              <span class="save-shortcut">(Ctrl+S)</span>
            </n-button>
          </div>
        </div>

        <!-- Ê≠£ÂèçÈù¢ÂàáÊç¢Ê†áÁ≠æ -->
        <div class="deck-side-tabs">
          <n-tabs v-model:value="currentSide" type="segment" size="large" @update:value="switchSide">
            <n-tab-pane name="front" tab="Ê≠£Èù¢ üéØ">
              <template #tab>
                <div class="side-tab">
                  <n-icon :component="LayersOutline" />
                  <span>Ê≠£Èù¢</span>
                  <n-badge :value="getFrontCardCount()" :max="99" show-zero type="info" />
                </div>
              </template>
            </n-tab-pane>
            <n-tab-pane name="back" tab="ËÉåÈù¢ üé≤">
              <template #tab>
                <div class="side-tab">
                  <n-icon :component="SwapHorizontalOutline" />
                  <span>ËÉåÈù¢</span>
                  <n-badge :value="getBackCardCount()" :max="99" show-zero type="warning" />
                </div>
              </template>
            </n-tab-pane>
          </n-tabs>
        </div>

        <n-scrollbar class="deck-grid-container">
          <div class="deck-grid-wrapper">
            <div class="deck-grid" :style="{
              gridTemplateColumns: `repeat(${selectedDeck.width}, 1fr)`,
              gridTemplateRows: `repeat(${selectedDeck.height}, 1fr)`
            }">
              <div v-for="index in (selectedDeck.width * selectedDeck.height)" :key="`${currentSide}-${index - 1}`"
                class="grid-slot" :class="{
                  'has-card': getCardAtIndex(index - 1, currentSide),
                  'drag-over': dragOverIndex === (index - 1),
                  'front-side': currentSide === 'front',
                  'back-side': currentSide === 'back'
                }" @click="selectGridSlot(index - 1)" @dragover.prevent="handleDragOver(index - 1)"
                @dragleave="handleDragLeave" @drop="handleDrop(index - 1)">
                <div v-if="getCardAtIndex(index - 1, currentSide)" class="card-in-slot"
                  :class="{ 'front-card': currentSide === 'front', 'back-card': currentSide === 'back' }"
                  draggable="true" @dragstart="handleDragStart(index - 1)" @dragend="handleDragEnd">
                  <!-- Âç°ÁâåÈ¢ÑËßàÂõæ -->
                  <div class="card-preview">
                    <img v-if="getCardPreviewImage(index - 1, currentSide)"
                      :src="getCardPreviewImage(index - 1, currentSide)"
                      :alt="getCardName(getCardAtIndex(index - 1, currentSide)!)" class="card-preview-image"
                      @error="handleImageError(index - 1, currentSide)" />
                    <div v-else class="card-placeholder">
                      <n-icon :component="ImageOutline" size="24" />
                    </div>
                  </div>
                  <div class="card-name">{{ getCardName(getCardAtIndex(index - 1, currentSide)!) }}</div>
                  <!-- ÊîπËøõÁöÑÂà†Èô§ÊåâÈíÆ -->
                  <div class="remove-card-btn-wrapper">
                    <n-button class="remove-card-btn" @click.stop="removeCardFromSlot(index - 1, currentSide)" text
                      type="error" size="tiny" circle>
                      <n-icon :component="CloseOutline" size="14" />
                    </n-button>
                  </div>
                </div>
                <div v-else class="empty-slot">
                  <div class="slot-index">{{ index - 1 }}</div>
                  <div class="add-hint">ÁÇπÂáªÊ∑ªÂä†ÂÜÖÂÆπ</div>
                  <div class="side-indicator">{{ currentSide === 'front' ? 'Ê≠£Èù¢' : 'ËÉåÈù¢' }}</div>
                </div>
              </div>
            </div>
          </div>
        </n-scrollbar>
      </div>

      <!-- Âè≥‰æßÂÜÖÂÆπÈÄâÊã©Èù¢Êùø -->
      <div class="card-select-panel" v-if="showCardSelector">
        <div class="panel-header">
          <h3>ÈÄâÊã©ÂÜÖÂÆπ - {{ currentSide === 'front' ? 'Ê≠£Èù¢' : 'ËÉåÈù¢' }}</h3>
          <n-button text @click="showCardSelector = false">
            <n-icon :component="CloseOutline" />
          </n-button>
        </div>
        <!-- ÈÄâÊã©Á±ªÂûãÁöÑÊ†áÁ≠æÈ°µ -->
        <div class="content-type-tabs">
          <n-tabs v-model:value="contentType" type="line" @update:value="switchContentType" class="full-height-tabs">
            <n-tab-pane name="cards" tab="üéØ Âç°Áâå" class="full-height-pane">
              <!-- ÊêúÁ¥¢Ê°Ü -->
              <div class="search-container">
                <n-input v-model:value="searchKeyword" placeholder="ÊêúÁ¥¢Âç°ÁâåÂêçÁß∞..." clearable>
                  <template #prefix>
                    <n-icon :component="SearchOutline" />
                  </template>
                </n-input>
              </div>
              <div class="scrollable-content">
                <n-scrollbar style="height: 100%;">
                  <div class="content-list-inner">
                    <div v-for="card in filteredCards" :key="card.path" class="content-item"
                      @click="assignContentToSlot('card', card.path)">
                      <div class="content-icon">üéØ</div>
                      <div class="content-info">
                        <div class="content-name">{{ card.name }}</div>
                        <div class="content-path">{{ card.path }}</div>
                      </div>
                    </div>
                    <n-empty v-if="filteredCards.length === 0" description="Ê≤°ÊúâÊâæÂà∞ÂåπÈÖçÁöÑÂç°Áâå">
                      <template #icon>
                        <n-icon :component="SearchOutline" />
                      </template>
                    </n-empty>
                  </div>
                </n-scrollbar>
              </div>
            </n-tab-pane>
            <n-tab-pane name="cardbacks" tab="üé¥ Âç°ËÉå" class="full-height-pane">
              <div class="scrollable-content">
                <n-scrollbar style="height: 100%;">
                  <div class="cardback-grid">
                    <div class="cardback-item" @click="assignContentToSlot('cardback', 'player')">
                      <div class="cardback-preview">
                        <img src="../../assets/cardbacks/player-back.jpg" alt="Áé©ÂÆ∂Âç°ËÉå" class="cardback-image"
                          @error="handleCardbackError" />
                      </div>
                      <div class="cardback-name">Áé©ÂÆ∂Âç°ËÉå</div>
                    </div>
                    <div class="cardback-item" @click="assignContentToSlot('cardback', 'encounter')">
                      <div class="cardback-preview">
                        <img src="../../assets/cardbacks/encounter-back.jpg" alt="ÈÅ≠ÈÅáÂç°ËÉå" class="cardback-image"
                          @error="handleCardbackError" />
                      </div>
                      <div class="cardback-name">ÈÅ≠ÈÅáÂç°ËÉå</div>
                    </div>
                  </div>
                </n-scrollbar>
              </div>
            </n-tab-pane>
            <n-tab-pane name="images" tab="üñºÔ∏è ÂõæÁâá" class="full-height-pane">
              <!-- ÂõæÁâáÊêúÁ¥¢Ê°Ü -->
              <div class="search-container">
                <n-input v-model:value="imageSearchKeyword" placeholder="ÊêúÁ¥¢ÂõæÁâáÊñá‰ª∂..." clearable>
                  <template #prefix>
                    <n-icon :component="SearchOutline" />
                  </template>
                </n-input>
              </div>
              <div class="scrollable-content">
                <n-scrollbar style="height: 100%;">
                  <div class="content-list-inner">
                    <div v-for="image in filteredImages" :key="image.path" class="content-item"
                      @click="assignContentToSlot('image', image.path)">
                      <div class="content-icon">üñºÔ∏è</div>
                      <div class="content-info">
                        <div class="content-name">{{ image.name }}</div>
                        <div class="content-path">{{ image.path }}</div>
                      </div>
                    </div>
                    <n-empty v-if="filteredImages.length === 0" description="Ê≤°ÊúâÊâæÂà∞ÂåπÈÖçÁöÑÂõæÁâá">
                      <template #icon>
                        <n-icon :component="ImageOutline" />
                      </template>
                    </n-empty>
                  </div>
                </n-scrollbar>
              </div>
            </n-tab-pane>
          </n-tabs>
        </div>
      </div>
    </div>

    <!-- Êñ∞Âª∫ÁâåÂ∫ìÂØπËØùÊ°Ü -->
    <n-modal v-model:show="showCreateDeckDialog" preset="dialog" title="Êñ∞Âª∫ÁâåÂ∫ì">
      <n-form ref="createFormRef" :model="newDeckForm" :rules="createRules">
        <n-form-item path="name" label="ÁâåÂ∫ìÂêçÁß∞">
          <n-input v-model:value="newDeckForm.name" placeholder="ËØ∑ËæìÂÖ•ÁâåÂ∫ìÂêçÁß∞" @keydown.enter="createDeck" clearable />
        </n-form-item>
        <n-grid :cols="2" :x-gap="12">
          <n-grid-item>
            <n-form-item path="width" label="ÂÆΩÂ∫¶ (1-10)">
              <n-input-number v-model:value="newDeckForm.width" :min="1" :max="10" placeholder="ÂÆΩÂ∫¶"
                :show-button="false" />
            </n-form-item>
          </n-grid-item>
          <n-grid-item>
            <n-form-item path="height" label="È´òÂ∫¶ (1-7)">
              <n-input-number v-model:value="newDeckForm.height" :min="1" :max="7" placeholder="È´òÂ∫¶"
                :show-button="false" />
            </n-form-item>
          </n-grid-item>
        </n-grid>
      </n-form>
      <template #action>
        <n-space>
          <n-button @click="closeCreateDialog">ÂèñÊ∂à</n-button>
          <n-button type="primary" @click="createDeck" :loading="creating">
            ÂàõÂª∫
          </n-button>
        </n-space>
      </template>
    </n-modal>

    <!-- Âà†Èô§Á°ÆËÆ§ÂØπËØùÊ°Ü -->
    <n-modal v-model:show="showDeleteDialog" preset="dialog" title="Âà†Èô§Á°ÆËÆ§">
      <n-alert type="warning" title="Ë≠¶Âëä">
        <template #icon>
          <n-icon :component="WarningOutline" />
        </template>
        Ê≠§Êìç‰Ωú‰∏çÂèØÊÅ¢Â§çÔºåÁ°ÆÂÆöË¶ÅÂà†Èô§ÁâåÂ∫ì"{{ deckToDelete?.name }}"ÂêóÔºü
      </n-alert>
      <template #action>
        <n-space>
          <n-button @click="showDeleteDialog = false">ÂèñÊ∂à</n-button>
          <n-button type="error" @click="confirmDeleteDeck" :loading="deleting">
            Âà†Èô§
          </n-button>
        </n-space>
      </template>
    </n-modal>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, computed, onUnmounted } from 'vue';
import {
  useMessage,
  type FormInst,
  type FormRules
} from 'naive-ui';
import {
  AddOutline,
  RefreshOutline,
  TrashOutline,
  FolderOpenOutline,
  SaveOutline,
  ImageOutline,
  CloseOutline,
  SearchOutline,
  WarningOutline,
  LayersOutline,
  SwapHorizontalOutline
} from '@vicons/ionicons5';
import { WorkspaceService, CardService } from '@/api';

interface DeckCard {
  index: number;
  type: 'card' | 'cardback' | 'image'; // Ê∑ªÂä†Á±ªÂûãÂ≠óÊÆµ
  path: string; // ÂØπ‰∫éÂç°ËÉåÔºåËøôÈáåÂ≠òÂÇ®Á±ªÂûãÔºàplayer/encounterÔºâ
}

interface DeckData {
  name: string;
  width: number;
  height: number;
  frontCards: DeckCard[]; // Ê≠£Èù¢Âç°Áâå
  backCards: DeckCard[];  // ËÉåÈù¢Âç°Áâå
}

interface DeckFile {
  name: string;
  path: string;
  width: number;
  height: number;
  frontCards: DeckCard[];
  backCards: DeckCard[];
}

interface CardFile {
  name: string;
  path: string;
}

interface ImageFile {
  name: string;
  path: string;
}

const message = useMessage();

// Áä∂ÊÄÅÁÆ°ÁêÜ
const loading = ref(false);
const saving = ref(false);
const creating = ref(false);
const deleting = ref(false);

// ÁâåÂ∫ìÁõ∏ÂÖ≥
const deckList = ref<DeckFile[]>([]);
const selectedDeck = ref<DeckFile | null>(null);
const currentSide = ref<'front' | 'back'>('front'); // ÂΩìÂâçÁºñËæëÁöÑÈù¢

// ÂÜÖÂÆπÈÄâÊã©Áõ∏ÂÖ≥
const availableCards = ref<CardFile[]>([]);
const availableImages = ref<ImageFile[]>([]);
const showCardSelector = ref(false);
const selectedSlotIndex = ref<number | null>(null);
const contentType = ref<'cards' | 'cardbacks' | 'images'>('cards'); // ÂΩìÂâçÈÄâÊã©ÁöÑÂÜÖÂÆπÁ±ªÂûã
const searchKeyword = ref('');
const imageSearchKeyword = ref('');

// ÂèåÈù¢Âç°ÁâåÈ¢ÑËßàÁºìÂ≠ò
const frontSlotCardImages = ref(new Map<number, string>());
const backSlotCardImages = ref(new Map<number, string>());

// ÊãñÊãΩÁõ∏ÂÖ≥
const dragOverIndex = ref<number | null>(null);
const dragSourceIndex = ref<number | null>(null);

// Êñ∞Âª∫ÁâåÂ∫ìË°®Âçï
const showCreateDeckDialog = ref(false);
const createFormRef = ref<FormInst | null>(null);
const newDeckForm = ref({
  name: '',
  width: 5 as number | null,
  height: 3 as number | null
});

// Âà†Èô§Á°ÆËÆ§ÂØπËØùÊ°Ü
const showDeleteDialog = ref(false);
const deckToDelete = ref<DeckFile | null>(null);

// Âõ∫ÂÆöÂç°ËÉåÂõæÁâáÔºà‰Ω†ÈúÄË¶ÅÂ∞ÜËøô‰∫õÂõæÁâáÊîæÂú® public/cardbacks/ ÁõÆÂΩï‰∏ãÔºâ
// Â¶ÇÊûúÂõæÁâáÂú® src/assets ÁõÆÂΩï‰∏ã
import playerBack from '@/assets/cardbacks/player-back.jpg'
import encounterBack from '@/assets/cardbacks/encounter-back.jpg'
const cardbackImages = {
  player: playerBack,
  encounter: encounterBack
}

// Ë°®ÂçïÈ™åËØÅËßÑÂàô
const createRules: FormRules = {
  name: [
    { required: true, message: 'ËØ∑ËæìÂÖ•ÁâåÂ∫ìÂêçÁß∞', trigger: ['input', 'blur'] },
    { min: 1, max: 50, message: 'ÁâåÂ∫ìÂêçÁß∞ÈïøÂ∫¶Âú®1-50‰∏™Â≠óÁ¨¶', trigger: ['input', 'blur'] },
    {
      pattern: /^[^\\/:*?"<>|]+$/,
      message: 'ÁâåÂ∫ìÂêçÁß∞‰∏çËÉΩÂåÖÂê´ÁâπÊÆäÂ≠óÁ¨¶ \\/:*?"<>|',
      trigger: ['input', 'blur']
    }
  ],
  width: [
    {
      required: true,
      message: 'ËØ∑ËæìÂÖ•ÂÆΩÂ∫¶',
      trigger: ['blur', 'change'],
      validator: (rule: any, value: any) => {
        if (value === null || value === undefined || value === '') {
          return new Error('ËØ∑ËæìÂÖ•ÂÆΩÂ∫¶');
        }
        if (typeof value !== 'number' || value < 1 || value > 10) {
          return new Error('ÂÆΩÂ∫¶ÂøÖÈ°ªÂú®1-10‰πãÈó¥');
        }
        return true;
      }
    }
  ],
  height: [
    {
      required: true,
      message: 'ËØ∑ËæìÂÖ•È´òÂ∫¶',
      trigger: ['blur', 'change'],
      validator: (rule: any, value: any) => {
        if (value === null || value === undefined || value === '') {
          return new Error('ËØ∑ËæìÂÖ•È´òÂ∫¶');
        }
        if (typeof value !== 'number' || value < 1 || value > 7) {
          return new Error('È´òÂ∫¶ÂøÖÈ°ªÂú®1-7‰πãÈó¥');
        }
        return true;
      }
    }
  ]
};

// ËøáÊª§ÂêéÁöÑÂç°ÁâåÂàóË°®
const filteredCards = computed(() => {
  if (!searchKeyword.value.trim()) {
    return availableCards.value;
  }

  const keyword = searchKeyword.value.toLowerCase().trim();
  return availableCards.value.filter(card =>
    card.name.toLowerCase().includes(keyword) ||
    card.path.toLowerCase().includes(keyword)
  );
});

// ËøáÊª§ÂêéÁöÑÂõæÁâáÂàóË°®
const filteredImages = computed(() => {
  if (!imageSearchKeyword.value.trim()) {
    return availableImages.value;
  }

  const keyword = imageSearchKeyword.value.toLowerCase().trim();
  return availableImages.value.filter(image =>
    image.name.toLowerCase().includes(keyword) ||
    image.path.toLowerCase().includes(keyword)
  );
});

// Ëé∑ÂèñÊ≠£Èù¢Âç°ÁâåÊï∞Èáè
const getFrontCardCount = () => {
  return selectedDeck.value?.frontCards.length || 0;
};

// Ëé∑ÂèñËÉåÈù¢Âç°ÁâåÊï∞Èáè
const getBackCardCount = () => {
  return selectedDeck.value?.backCards.length || 0;
};

// ÂàáÊç¢ÁºñËæëÈù¢
const switchSide = (side: 'front' | 'back') => {
  currentSide.value = side;
  showCardSelector.value = false;
};

// ÂàáÊç¢ÂÜÖÂÆπÁ±ªÂûã
const switchContentType = (type: 'cards' | 'cardbacks' | 'images') => {
  contentType.value = type;
  if (type === 'images' && availableImages.value.length === 0) {
    loadAvailableImages();
  }
};

// ÂéãÁº©ÂõæÁâá
const compressImage = (base64: string, maxWidth = 150, quality = 0.7): Promise<string> => {
  return new Promise((resolve) => {
    const img = new Image();
    img.onload = () => {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d')!;

      const ratio = Math.min(maxWidth / img.width, maxWidth / img.height);
      canvas.width = img.width * ratio;
      canvas.height = img.height * ratio;

      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      resolve(canvas.toDataURL('image/jpeg', quality));
    };
    img.src = base64;
  });
};

// ‰∏∫Âçï‰∏™ÁΩëÊ†º‰ΩçÁΩÆÁîüÊàêÂÜÖÂÆπÈ¢ÑËßàÂõæ
const generateSlotContentPreview = async (index: number, item: DeckCard, side: 'front' | 'back') => {
  try {
    let imageBase64: string | null = null;

    if (item.type === 'card') {
      const content = await WorkspaceService.getFileContent(item.path);
      const cardData = JSON.parse(content);
      imageBase64 = await CardService.generateCard(cardData);
    } else if (item.type === 'cardback') {
      // Âä†ËΩΩÂõ∫ÂÆöÁöÑÂç°ËÉåÂõæÁâá
      const cardbackPath = cardbackImages[item.path as 'player' | 'encounter'];
      if (cardbackPath) {
        // Â∞ÜË∑ØÂæÑËΩ¨Êç¢‰∏∫base64
        imageBase64 = await loadImageAsBase64(cardbackPath);
      }
    } else if (item.type === 'image') {
      // Âä†ËΩΩÂ∑•‰ΩúÁõÆÂΩï‰∏≠ÁöÑÂõæÁâáÊñá‰ª∂
      imageBase64 = await loadWorkspaceImageAsBase64(item.path);
    }

    if (imageBase64) {
      const compressedImage = await compressImage(imageBase64, 120, 0.7);
      if (side === 'front') {
        frontSlotCardImages.value.set(index, compressedImage);
      } else {
        backSlotCardImages.value.set(index, compressedImage);
      }
    }
  } catch (error) {
    console.error(`ÁîüÊàêÂÜÖÂÆπÈ¢ÑËßàÂ§±Ë¥•: ${item.path}`, error);
  }
};

// Âä†ËΩΩÂõæÁâá‰∏∫Base64
const loadImageAsBase64 = (src: string): Promise<string> => {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.onload = () => {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d')!;
      canvas.width = img.width;
      canvas.height = img.height;
      ctx.drawImage(img, 0, 0);
      resolve(canvas.toDataURL());
    };
    img.onerror = reject;
    img.src = src;
  });
};

// Âä†ËΩΩÂ∑•‰ΩúÁ©∫Èó¥ÂõæÁâá‰∏∫Base64
const loadWorkspaceImageAsBase64 = async (path: string): Promise<string> => {
  // ËøôÈáå‰Ω†ÈúÄË¶ÅÊ†πÊçÆ‰Ω†ÁöÑAPIÂÆûÁé∞Êù•Ëé∑ÂèñÂ∑•‰ΩúÁ©∫Èó¥‰∏≠ÁöÑÂõæÁâáÊñá‰ª∂
  // ÂÅáËÆæWorkspaceServiceÊúâ‰∏Ä‰∏™ÊñπÊ≥ïÂèØ‰ª•Ëé∑ÂèñÂõæÁâáÁöÑbase64
  try {
    const content = await WorkspaceService.getImageContent(path);
    return `${content}`;
  } catch (error) {
    console.error('Âä†ËΩΩÂ∑•‰ΩúÁ©∫Èó¥ÂõæÁâáÂ§±Ë¥•:', error);
    throw error;
  }
};

// Ëé∑ÂèñÂç°ÁâåÂú®ÁΩëÊ†º‰∏≠ÁöÑÈ¢ÑËßàÂõæ
const getCardPreviewImage = (index: number, side: 'front' | 'back'): string | null => {
  if (side === 'front') {
    return frontSlotCardImages.value.get(index) || null;
  } else {
    return backSlotCardImages.value.get(index) || null;
  }
};

// Â§ÑÁêÜÂõæÁâáÂä†ËΩΩÈîôËØØ
const handleImageError = (index: number, side: 'front' | 'back') => {
  if (side === 'front') {
    frontSlotCardImages.value.delete(index);
  } else {
    backSlotCardImages.value.delete(index);
  }
};

// Â§ÑÁêÜÂç°ËÉåÂõæÁâáÂä†ËΩΩÈîôËØØ
const handleCardbackError = (event: Event) => {
  const img = event.target as HTMLImageElement;
  img.style.display = 'none';
  // ÂèØ‰ª•Âú®ËøôÈáåÊ∑ªÂä†ÈªòËÆ§ÂõæÁâáÊàñÂç†‰ΩçÁ¨¶
};

// Á°Æ‰øùDeckBuilderÁõÆÂΩïÂ≠òÂú®
const ensureDeckBuilderDirectory = async () => {
  try {
    await WorkspaceService.createDirectory('DeckBuilder');
  } catch (error) {
    console.log('DeckBuilderÁõÆÂΩïÂ∑≤Â≠òÂú®ÊàñÂàõÂª∫Â§±Ë¥•:', error);
  }
};

// Âä†ËΩΩÊâÄÊúâÁâåÂ∫ì
const loadDecks = async () => {
  loading.value = true;
  try {
    await ensureDeckBuilderDirectory();

    const response = await WorkspaceService.getFileTree();
    const deckBuilderNode = findDeckBuilderNode(response.fileTree);

    if (deckBuilderNode && deckBuilderNode.children) {
      const deckFiles = deckBuilderNode.children.filter(
        (file: any) => file.label.endsWith('.deck')
      );

      const decks: DeckFile[] = [];
      for (const file of deckFiles) {
        try {
          const content = await WorkspaceService.getFileContent(file.path);
          const deckData: DeckData = JSON.parse(content);

          // ÂÖºÂÆπÊóßÊ†ºÂºèÂíåÊñ∞Ê†ºÂºè
          let frontCards = deckData.frontCards || [];
          let backCards = deckData.backCards || [];

          // Â¶ÇÊûúÊòØÊóßÊ†ºÂºèÔºåËΩ¨Êç¢‰∏∫Êñ∞Ê†ºÂºè
          if ((deckData as any).cards && !deckData.frontCards) {
            frontCards = (deckData as any).cards.map((card: any) => ({
              index: card.index,
              type: 'card',
              path: card.cardPath || card.path
            }));
          }

          decks.push({
            name: deckData.name,
            path: file.path,
            width: deckData.width,
            height: deckData.height,
            frontCards: frontCards,
            backCards: backCards
          });
        } catch (error) {
          console.error(`Âä†ËΩΩÁâåÂ∫ìÊñá‰ª∂Â§±Ë¥•: ${file.path}`, error);
        }
      }

      deckList.value = decks;
    } else {
      deckList.value = [];
    }

    await loadAvailableCards();
    message.success('ÁâåÂ∫ìÂàóË°®Â∑≤Âà∑Êñ∞');
  } catch (error) {
    console.error('Âä†ËΩΩÁâåÂ∫ìÂàóË°®Â§±Ë¥•:', error);
    message.error('Âä†ËΩΩÁâåÂ∫ìÂàóË°®Â§±Ë¥•ÔºåËØ∑ÈáçËØï');
  } finally {
    loading.value = false;
  }
};

// Êü•ÊâæDeckBuilderËäÇÁÇπ
const findDeckBuilderNode = (node: any): any => {
  if (node.label === 'DeckBuilder') return node;
  if (node.children) {
    for (const child of node.children) {
      const found = findDeckBuilderNode(child);
      if (found) return found;
    }
  }
  return null;
};

// Âä†ËΩΩÂèØÁî®Âç°Áâå
const loadAvailableCards = async () => {
  try {
    const response = await WorkspaceService.getFileTree();
    const cards: CardFile[] = [];

    const collectCards = (node: any) => {
      if (node.type === 'card') {
        cards.push({
          name: node.label.replace('.card', ''),
          path: node.path
        });
      }
      if (node.children) {
        node.children.forEach(collectCards);
      }
    };

    collectCards(response.fileTree);
    availableCards.value = cards;
  } catch (error) {
    console.error('Âä†ËΩΩÂèØÁî®Âç°ÁâåÂ§±Ë¥•:', error);
    message.error('Âä†ËΩΩÂèØÁî®Âç°ÁâåÂ§±Ë¥•');
  }
};

// Âä†ËΩΩÂèØÁî®ÂõæÁâá
const loadAvailableImages = async () => {
  try {
    const response = await WorkspaceService.getFileTree();
    const images: ImageFile[] = [];

    const collectImages = (node: any) => {
      // ‰øÆÊîπÔºöÊ£ÄÊü•ÂõæÁâáÁ±ªÂûãÊàñÈÄöËøáÊñá‰ª∂Êâ©Â±ïÂêçÂà§Êñ≠
      const isImageByType = node.type === 'image';
      const isImageByExtension = node.type === 'file' && /\.(png|jpg|jpeg|gif|bmp|webp|svg)$/i.test(node.label);

      if (isImageByType || isImageByExtension) {
        images.push({
          name: node.label,
          path: node.path
        });
      }

      if (node.children) {
        node.children.forEach(collectImages);
      }
    };

    collectImages(response.fileTree);
    availableImages.value = images;
    console.log('Âä†ËΩΩÂà∞ÁöÑÂõæÁâáÊñá‰ª∂:', images); // Ê∑ªÂä†Ë∞ÉËØïÊó•Âøó
  } catch (error) {
    console.error('Âä†ËΩΩÂèØÁî®ÂõæÁâáÂ§±Ë¥•:', error);
    message.error('Âä†ËΩΩÂèØÁî®ÂõæÁâáÂ§±Ë¥•');
  }
};


// ÈÄâÊã©ÁâåÂ∫ì
const selectDeck = async (deck: DeckFile) => {
  selectedDeck.value = deck;
  showCardSelector.value = false;
  currentSide.value = 'front';

  // Ê∏ÖÁ©∫‰πãÂâçÁöÑÈ¢ÑËßàÂõæ
  frontSlotCardImages.value.clear();
  backSlotCardImages.value.clear();

  // ‰∏∫ÁâåÂ∫ì‰∏≠ÁöÑÊ≠£Èù¢ÂÜÖÂÆπÁîüÊàêÈ¢ÑËßàÂõæ
  for (const item of deck.frontCards) {
    generateSlotContentPreview(item.index, item, 'front');
  }

  // ‰∏∫ÁâåÂ∫ì‰∏≠ÁöÑËÉåÈù¢ÂÜÖÂÆπÁîüÊàêÈ¢ÑËßàÂõæ
  for (const item of deck.backCards) {
    generateSlotContentPreview(item.index, item, 'back');
  }
};

// ÂàõÂª∫Êñ∞ÁâåÂ∫ì
const createDeck = async () => {
  if (!createFormRef.value) return;

  try {
    await createFormRef.value.validate();
    creating.value = true;

    await ensureDeckBuilderDirectory();

    const deckData: DeckData = {
      name: newDeckForm.value.name,
      width: newDeckForm.value.width!,
      height: newDeckForm.value.height!,
      frontCards: [],
      backCards: []
    };

    const fileName = `${newDeckForm.value.name}.deck`;
    const filePath = `DeckBuilder/${fileName}`;

    await WorkspaceService.createFile(fileName, JSON.stringify(deckData, null, 2), 'DeckBuilder');

    deckList.value.push({
      name: deckData.name,
      path: filePath,
      width: deckData.width,
      height: deckData.height,
      frontCards: deckData.frontCards,
      backCards: deckData.backCards
    });

    closeCreateDialog();
    message.success('ÁâåÂ∫ìÂàõÂª∫ÊàêÂäü');
  } catch (error) {
    if (error && typeof error === 'object' && 'errors' in error) {
      return;
    }
    console.error('ÂàõÂª∫ÁâåÂ∫ìÂ§±Ë¥•:', error);
    message.error('ÂàõÂª∫ÁâåÂ∫ìÂ§±Ë¥•ÔºåËØ∑ÈáçËØï');
  } finally {
    creating.value = false;
  }
};

// ÂÖ≥Èó≠ÂàõÂª∫ÂØπËØùÊ°Ü
const closeCreateDialog = () => {
  showCreateDeckDialog.value = false;
  newDeckForm.value = {
    name: '',
    width: 5,
    height: 3
  };
  createFormRef.value?.restoreValidation();
};

// ‰øùÂ≠òÁâåÂ∫ì
const saveDeck = async () => {
  if (!selectedDeck.value) return;

  saving.value = true;
  try {
    const deckData: DeckData = {
      name: selectedDeck.value.name,
      width: selectedDeck.value.width,
      height: selectedDeck.value.height,
      frontCards: selectedDeck.value.frontCards,
      backCards: selectedDeck.value.backCards
    };

    await WorkspaceService.saveFileContent(
      selectedDeck.value.path,
      JSON.stringify(deckData, null, 2)
    );

    message.success('ÁâåÂ∫ì‰øùÂ≠òÊàêÂäü');
  } catch (error) {
    console.error('‰øùÂ≠òÁâåÂ∫ìÂ§±Ë¥•:', error);
    message.error('‰øùÂ≠òÁâåÂ∫ìÂ§±Ë¥•ÔºåËØ∑ÈáçËØï');
  } finally {
    saving.value = false;
  }
};

// ÊòæÁ§∫Âà†Èô§Á°ÆËÆ§ÂØπËØùÊ°Ü
const showDeleteConfirm = (deck: DeckFile) => {
  deckToDelete.value = deck;
  showDeleteDialog.value = true;
};

// Á°ÆËÆ§Âà†Èô§ÁâåÂ∫ì
const confirmDeleteDeck = async () => {
  if (!deckToDelete.value) return;

  deleting.value = true;
  try {
    await WorkspaceService.deleteItem(deckToDelete.value.path);

    const index = deckList.value.findIndex(d => d.path === deckToDelete.value!.path);
    if (index > -1) {
      deckList.value.splice(index, 1);
    }

    if (selectedDeck.value?.path === deckToDelete.value.path) {
      selectedDeck.value = null;
      frontSlotCardImages.value.clear();
      backSlotCardImages.value.clear();
    }

    showDeleteDialog.value = false;
    deckToDelete.value = null;
    message.success('ÁâåÂ∫ìÂà†Èô§ÊàêÂäü');
  } catch (error) {
    console.error('Âà†Èô§ÁâåÂ∫ìÂ§±Ë¥•:', error);
    message.error('Âà†Èô§ÁâåÂ∫ìÂ§±Ë¥•ÔºåËØ∑ÈáçËØï');
  } finally {
    deleting.value = false;
  }
};

// Ëé∑ÂèñÊåáÂÆö‰ΩçÁΩÆÂíåÈù¢ÁöÑÂÜÖÂÆπ
const getCardAtIndex = (index: number, side: 'front' | 'back'): string | null => {
  if (!selectedDeck.value) return null;
  const cards = side === 'front' ? selectedDeck.value.frontCards : selectedDeck.value.backCards;
  const card = cards.find(c => c.index === index);
  return card ? card.path : null;
};

// Ëé∑ÂèñÂÜÖÂÆπÊòæÁ§∫ÂêçÁß∞
const getCardName = (path: string): string => {
  if (!selectedDeck.value) return '';

  const cards = [...selectedDeck.value.frontCards, ...selectedDeck.value.backCards];
  const item = cards.find(c => c.path === path);

  if (!item) return path;

  if (item.type === 'cardback') {
    return item.path === 'player' ? 'Áé©ÂÆ∂Âç°ËÉå' : 'ÈÅ≠ÈÅáÂç°ËÉå';
  } else if (item.type === 'card') {
    const card = availableCards.value.find(c => c.path === path);
    return card ? card.name : path.split('/').pop()?.replace('.card', '') || '';
  } else if (item.type === 'image') {
    return path.split('/').pop() || '';
  }

  return path;
};

// ÈÄâÊã©ÁΩëÊ†º‰ΩçÁΩÆ
const selectGridSlot = (index: number) => {
  selectedSlotIndex.value = index;
  showCardSelector.value = true;
};

// ÂàÜÈÖçÂÜÖÂÆπÂà∞‰ΩçÁΩÆ
const assignContentToSlot = async (type: 'card' | 'cardback' | 'image', path: string) => {
  if (!selectedDeck.value || selectedSlotIndex.value === null) return;

  const index = selectedSlotIndex.value;
  const cards = currentSide.value === 'front' ? selectedDeck.value.frontCards : selectedDeck.value.backCards;

  // ÁßªÈô§ËØ•‰ΩçÁΩÆÁé∞ÊúâÁöÑÂÜÖÂÆπ
  const filteredCards = cards.filter(c => c.index !== index);

  // Ê∑ªÂä†Êñ∞ÂÜÖÂÆπ
  const newItem: DeckCard = {
    index,
    type,
    path
  };

  filteredCards.push(newItem);

  // Êõ¥Êñ∞ÂØπÂ∫îÈù¢ÁöÑÂÜÖÂÆπ
  if (currentSide.value === 'front') {
    selectedDeck.value.frontCards = filteredCards;
  } else {
    selectedDeck.value.backCards = filteredCards;
  }

  // ÁîüÊàêÈ¢ÑËßàÂõæ
  generateSlotContentPreview(index, newItem, currentSide.value);

  showCardSelector.value = false;
  selectedSlotIndex.value = null;

  let typeName = '';
  if (type === 'card') typeName = 'Âç°Áâå';
  else if (type === 'cardback') typeName = 'Âç°ËÉå';
  else if (type === 'image') typeName = 'ÂõæÁâá';

  message.success(`${typeName}Â∑≤Ê∑ªÂä†Âà∞${currentSide.value === 'front' ? 'Ê≠£Èù¢' : 'ËÉåÈù¢'}`);
};

// ‰ªé‰ΩçÁΩÆÁßªÈô§ÂÜÖÂÆπ
const removeCardFromSlot = (index: number, side: 'front' | 'back') => {
  if (!selectedDeck.value) return;

  if (side === 'front') {
    selectedDeck.value.frontCards = selectedDeck.value.frontCards.filter(c => c.index !== index);
    frontSlotCardImages.value.delete(index);
  } else {
    selectedDeck.value.backCards = selectedDeck.value.backCards.filter(c => c.index !== index);
    backSlotCardImages.value.delete(index);
  }

  message.info('ÂÜÖÂÆπÂ∑≤ÁßªÈô§');
};

// ÊãñÊãΩÂºÄÂßã
const handleDragStart = (index: number) => {
  dragSourceIndex.value = index;
};

// ÊãñÊãΩÁªìÊùü
const handleDragEnd = () => {
  dragSourceIndex.value = null;
  dragOverIndex.value = null;
};

// ÊãñÊãΩÊÇ¨ÂÅú
const handleDragOver = (index: number) => {
  dragOverIndex.value = index;
};

// ÊãñÊãΩÁ¶ªÂºÄ
const handleDragLeave = () => {
  dragOverIndex.value = null;
};

// ÊãñÊãΩÊîæÁΩÆ
const handleDrop = (targetIndex: number) => {
  if (!selectedDeck.value || dragSourceIndex.value === null) return;

  const sourceIndex = dragSourceIndex.value;

  if (sourceIndex === targetIndex) return;

  const cards = currentSide.value === 'front' ? selectedDeck.value.frontCards : selectedDeck.value.backCards;
  const sourceCard = cards.find(c => c.index === sourceIndex);
  const targetCard = cards.find(c => c.index === targetIndex);

  // ‰∫§Êç¢‰ΩçÁΩÆ
  if (sourceCard && targetCard) {
    sourceCard.index = targetIndex;
    targetCard.index = sourceIndex;

    // ‰∫§Êç¢È¢ÑËßàÂõæ
    const images = currentSide.value === 'front' ? frontSlotCardImages.value : backSlotCardImages.value;
    const sourceImage = images.get(sourceIndex);
    const targetImage = images.get(targetIndex);
    if (sourceImage && targetImage) {
      images.set(targetIndex, sourceImage);
      images.set(sourceIndex, targetImage);
    }
  } else if (sourceCard) {
    sourceCard.index = targetIndex;

    // ÁßªÂä®È¢ÑËßàÂõæ
    const images = currentSide.value === 'front' ? frontSlotCardImages.value : backSlotCardImages.value;
    const sourceImage = images.get(sourceIndex);
    if (sourceImage) {
      images.delete(sourceIndex);
      images.set(targetIndex, sourceImage);
    }
  }

  dragSourceIndex.value = null;
  dragOverIndex.value = null;
  message.info('ÂÜÖÂÆπ‰ΩçÁΩÆÂ∑≤Ë∞ÉÊç¢');
};

// ÈîÆÁõòÂø´Êç∑ÈîÆÂ§ÑÁêÜ
const handleKeydown = (event: KeyboardEvent) => {
  if ((event.ctrlKey || event.metaKey) && event.key === 's') {
    event.preventDefault();
    if (selectedDeck.value && !saving.value) {
      saveDeck();
    }
  }
};

// ÁªÑ‰ª∂ÊåÇËΩΩÊó∂Âä†ËΩΩÊï∞ÊçÆ
onMounted(() => {
  loadDecks();
  document.addEventListener('keydown', handleKeydown);
});

// ÁªÑ‰ª∂Âç∏ËΩΩÊó∂Ê∏ÖÁêÜ
onUnmounted(() => {
  document.removeEventListener('keydown', handleKeydown);
});
</script>

<style scoped>
.deck-builder-container {
  height: 100vh;
  display: flex;
  flex-direction: column;
  background: #f8f9fa;
}

.deck-builder-header {
  flex-shrink: 0;
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1.5rem 2rem;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  box-shadow: 0 4px 20px rgba(102, 126, 234, 0.3);
}

.deck-builder-header h2 {
  margin: 0;
  font-size: 1.5rem;
  font-weight: 600;
}

.deck-builder-content {
  flex: 1;
  display: flex;
  overflow: hidden;
  min-height: 0;
}

.deck-list-panel {
  width: 280px;
  background: white;
  border-right: 1px solid #e9ecef;
  display: flex;
  flex-direction: column;
  min-height: 0;
}

.deck-editor-panel {
  flex: 1;
  background: white;
  margin: 1rem;
  border-radius: 12px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
  display: flex;
  flex-direction: column;
  overflow: hidden;
  min-height: 0;
}

.card-select-panel {
  width: 380px;
  background: white;
  border-left: 1px solid #e9ecef;
  display: flex;
  flex-direction: column;
  min-height: 0;
}

.panel-header {
  flex-shrink: 0;
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.5rem;
  border-bottom: 1px solid #e9ecef;
  background: #f8f9fa;
}

.panel-header h3 {
  margin: 0;
  color: #2c3e50;
  font-size: 1.1rem;
}

.editor-actions {
  display: flex;
  gap: 0.5rem;
}

/* Ê≠£ÂèçÈù¢ÂàáÊç¢Ê†áÁ≠æ */
.deck-side-tabs {
  flex-shrink: 0;
  border-bottom: 1px solid #e9ecef;
  background: #fafafa;
  padding: 1rem 1.5rem 0;
}

.side-tab {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

/* ÂÜÖÂÆπÁ±ªÂûãÊ†áÁ≠æÈ°µ */
.content-type-tabs {
  flex: 1;
  display: flex;
  flex-direction: column;
  min-height: 0;
  overflow: hidden;
}

/* ‰øÆÂ§çNaive UI tabsÁªÑ‰ª∂ÁöÑÈ´òÂ∫¶ÈóÆÈ¢ò */
.full-height-tabs {
  height: 100%;
  display: flex;
  flex-direction: column;
}

.full-height-tabs :deep(.n-tabs-nav) {
  flex-shrink: 0;
}

.full-height-tabs :deep(.n-tabs-content) {
  flex: 1;
  min-height: 0;
  overflow: hidden;
}

.full-height-tabs :deep(.n-tab-pane) {
  height: 100%;
  display: flex;
  flex-direction: column;
  min-height: 0;
}

/* Êñ∞Â¢ûÁöÑÂèØÊªöÂä®ÂÜÖÂÆπÂÆπÂô® */
.scrollable-content {
  flex: 1;
  min-height: 0;
  overflow: hidden;
}

.content-list-inner {
  padding: 0.5rem;
}

/* ÊòæËëóÁöÑ‰øùÂ≠òÊåâÈíÆÊ†∑Âºè */
.save-button {
  background: linear-gradient(135deg, #28a745 0%, #20c997 100%) !important;
  border: none !important;
  box-shadow: 0 4px 15px rgba(40, 167, 69, 0.3);
  transition: all 0.3s ease;
  font-weight: 600;
}

.save-button:hover {
  background: linear-gradient(135deg, #218838 0%, #17a2b8 100%) !important;
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(40, 167, 69, 0.4);
}

.save-shortcut {
  font-size: 0.8rem;
  opacity: 0.8;
  margin-left: 0.5rem;
}

.deck-list {
  flex: 1;
  min-height: 0;
  padding: 0.5rem;
}

.deck-item {
  display: flex;
  align-items: center;
  padding: 0.75rem;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s ease;
  margin-bottom: 0.25rem;
  position: relative;
}

.deck-item:hover {
  background: #f8f9fa;
}

.deck-item.active {
  background: linear-gradient(135deg, #e3f2fd 0%, #e8f5e8 100%);
  border-left: 3px solid #667eea;
}

.deck-icon {
  font-size: 1.25rem;
  margin-right: 0.75rem;
}

.deck-info {
  flex: 1;
}

.deck-name {
  font-weight: 500;
  color: #2c3e50;
  margin-bottom: 0.25rem;
}

.deck-meta {
  font-size: 0.8rem;
  color: #6c757d;
}

/* ÊîπËøõÁöÑÁΩëÊ†ºÂÆπÂô®Â∏ÉÂ±Ä */
.deck-grid-container {
  flex: 1;
  min-height: 0;
  padding: 2rem; /* Â¢ûÂä†paddingÁªôÂà†Èô§ÊåâÈíÆÁïôÁ©∫Èó¥ */
  overflow-x: auto;
  overflow-y: auto;
}

.deck-grid-wrapper {
  min-height: 100%;
  display: flex;
  align-items: flex-start;
  justify-content: center;
  padding: 1rem;
}

.deck-grid {
  display: grid;
  gap: 1.2rem; /* Á®çÂæÆÂ¢ûÂä†Èó¥Ë∑ùÁªôÂà†Èô§ÊåâÈíÆÁïôÁ©∫Èó¥ */
  justify-content: center;
  align-content: flex-start;
  width: fit-content;
  margin: 0 auto;
}

/* Áªü‰∏ÄÁΩëÊ†ºÊßΩÂ∞∫ÂØ∏ - ÂÖ≥ÈîÆ‰øÆÂ§çÔºö‰∏çË£ÅÂâ™Âà†Èô§ÊåâÈíÆ */
.grid-slot {
  width: 140px;
  height: 200px;
  border: 2px dashed #ddd;
  border-radius: 12px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.3s ease;
  position: relative;
  background: #fafafa;
  box-sizing: border-box;
  /* ÂÖ≥ÈîÆ‰øÆÂ§çÔºö‰∏çË¶ÅËÆæÁΩÆ overflow: hiddenÔºåËÆ©Âà†Èô§ÊåâÈíÆÂèØ‰ª•‰º∏Âá∫ */
}

.grid-slot:hover {
  border-color: #667eea;
  background: #f0f4ff;
  transform: translateY(-3px);
  box-shadow: 0 6px 20px rgba(102, 126, 234, 0.2);
}

.grid-slot.has-card {
  border: 2px solid #667eea;
  background: white;
}

.grid-slot.front-side.has-card {
  border-color: #667eea;
  box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
}

.grid-slot.back-side.has-card {
  border-color: #ff6b6b;
  box-shadow: 0 4px 12px rgba(255, 107, 107, 0.2);
}

.grid-slot.drag-over {
  border-color: #28a745;
  background: #e8f5e8;
  transform: scale(1.02);
}

/* Áªü‰∏ÄÂç°ÁâáÂÆπÂô®Â∞∫ÂØ∏ - ÂÖ≥ÈîÆ‰øÆÂ§çÔºö‰∏çË£ÅÂâ™Âà†Èô§ÊåâÈíÆ */
.card-in-slot {
  width: 100%;
  height: 100%;
  background: white;
  border-radius: 10px;
  padding: 8px;
  display: flex;
  flex-direction: column;
  box-shadow: 0 3px 12px rgba(0, 0, 0, 0.15);
  position: relative;
  cursor: grab;
  box-sizing: border-box;
  /* ÂÖ≥ÈîÆ‰øÆÂ§çÔºöÁßªÈô§ overflow: hiddenÔºåËÆ©Âà†Èô§ÊåâÈíÆÂèØ‰ª•‰º∏Âá∫ */
}

.card-in-slot.front-card {
  border-left: 4px solid #667eea;
}

.card-in-slot.back-card {
  border-left: 4px solid #ff6b6b;
}

.card-in-slot:active {
  cursor: grabbing;
}

/* Áªü‰∏ÄÂç°ÁâáÈ¢ÑËßàÂå∫Âüü */
.card-preview {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 8px;
  overflow: hidden;
  margin-bottom: 8px;
  background: #f8f9fa;
  position: relative;
  min-height: 0;
}

/* Áªü‰∏ÄÂõæÁâáÊòæÁ§∫ÊñπÂºè */
.card-preview-image {
  width: 100%;
  height: 100%;
  object-fit: cover;
  object-position: center;
  border-radius: 6px;
  display: block;
}

.card-placeholder {
  display: flex;
  align-items: center;
  justify-content: center;
  color: #6c757d;
  font-size: 2rem;
  width: 100%;
  height: 100%;
}

/* Áªü‰∏ÄÂç°ÁâáÂêçÁß∞ÊòæÁ§∫ */
.card-name {
  font-weight: 500;
  font-size: 0.75rem;
  color: #2c3e50;
  text-align: center;
  line-height: 1.2;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  margin-bottom: 4px;
  height: 1.2em;
  flex-shrink: 0;
}

/* ÂÖ≥ÈîÆ‰øÆÂ§çÔºöÂà†Èô§ÊåâÈíÆ‰ΩçÁΩÆÂíåÂ∞∫ÂØ∏ */
.remove-card-btn-wrapper {
  position: absolute;
  top: -6px; /* Ë∞ÉÊï¥‰ΩçÁΩÆÔºå‰∏çË¶Å‰º∏Âá∫Â§™Â§ö */
  right: -6px; /* Ë∞ÉÊï¥‰ΩçÁΩÆÔºå‰∏çË¶Å‰º∏Âá∫Â§™Â§ö */
  z-index: 100; /* Á°Æ‰øùÂú®ÊúÄ‰∏äÂ±Ç */
}

.remove-card-btn {
  width: 28px !important; /* Â¢ûÂä†Â∞∫ÂØ∏ËÆ©Êõ¥ÂÆπÊòìÁÇπÂáª */
  height: 28px !important; /* Â¢ûÂä†Â∞∫ÂØ∏ËÆ©Êõ¥ÂÆπÊòìÁÇπÂáª */
  min-width: 28px !important; /* Èò≤Ê≠¢ÊåâÈíÆË¢´ÂéãÁº© */
  min-height: 28px !important; /* Èò≤Ê≠¢ÊåâÈíÆË¢´ÂéãÁº© */
  background: #dc3545 !important;
  border: 2px solid white !important;
  border-radius: 50% !important; /* Á°Æ‰øùÊòØÂúÜÂΩ¢ */
  box-shadow: 0 3px 10px rgba(220, 53, 69, 0.4) !important;
  opacity: 0;
  transition: all 0.2s ease;
  color: white !important;
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  cursor: pointer !important;
}

.remove-card-btn:hover {
  background: #c82333 !important;
  transform: scale(1.15) !important; /* Á®çÂæÆÊîæÂ§ßËÆ©Êõ¥ÂÆπÊòìÁÇπÂáª */
  box-shadow: 0 5px 15px rgba(220, 53, 69, 0.6) !important;
  color: white !important;
}

.remove-card-btn .n-icon {
  color: white !important;
  font-size: 14px !important;
}

/* Á°Æ‰øùÊåâÈíÆÂú®ÊÇ¨ÂÅúÊó∂ÊòæÁ§∫ */
.card-in-slot:hover .remove-card-btn,
.grid-slot:hover .remove-card-btn {
  opacity: 1;
}

/* Á©∫ÊßΩÊ†∑Âºè */
.empty-slot {
  text-align: center;
  color: #6c757d;
  padding: 1rem;
  height: 100%;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
}

.slot-index {
  font-size: 1.5rem;
  font-weight: bold;
  margin-bottom: 0.5rem;
  color: #495057;
}

.add-hint {
  font-size: 0.8rem;
  margin-bottom: 0.5rem;
  opacity: 0.7;
}

.side-indicator {
  font-size: 0.7rem;
  padding: 0.25rem 0.5rem;
  border-radius: 12px;
  background: #e9ecef;
  color: #6c757d;
  margin-top: auto;
}

.search-container {
  flex-shrink: 0;
  padding: 1rem;
  border-bottom: 1px solid #e9ecef;
}

.content-item {
  display: flex;
  align-items: center;
  padding: 0.75rem;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s ease;
  margin-bottom: 0.5rem;
  border: 1px solid transparent;
}

.content-item:hover {
  background: #f8f9fa;
  border-color: #667eea;
}

.content-icon {
  font-size: 1.25rem;
  margin-right: 0.75rem;
  color: #667eea;
}

.content-info {
  flex: 1;
  min-width: 0;
}

.content-name {
  font-weight: 500;
  color: #2c3e50;
  margin-bottom: 0.25rem;
}

.content-path {
  font-size: 0.75rem;
  color: #6c757d;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

/* Âç°ËÉåÁΩëÊ†ºÊ†∑Âºè */
.cardback-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 1rem;
  padding: 1rem;
}

.cardback-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 1rem;
  border: 2px dashed #ddd;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.cardback-item:hover {
  border-color: #667eea;
  background: #f0f4ff;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
}

.cardback-preview {
  width: 80px;
  height: 110px;
  border-radius: 6px;
  overflow: hidden;
  margin-bottom: 0.5rem;
  background: #f8f9fa;
  display: flex;
  align-items: center;
  justify-content: center;
}

.cardback-image {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.cardback-name {
  font-size: 0.8rem;
  font-weight: 500;
  color: #2c3e50;
  text-align: center;
}

/* ÂìçÂ∫îÂºèË∞ÉÊï¥ */
@media (max-width: 1400px) {
  .grid-slot {
    width: 120px;
    height: 170px;
  }
  
  .deck-grid {
    gap: 1rem;
  }
}

@media (max-width: 1200px) {
  .grid-slot {
    width: 110px;
    height: 150px;
  }
  
  .deck-grid {
    gap: 0.8rem;
  }
  
  .card-name {
    font-size: 0.7rem;
  }
  
  .remove-card-btn {
    width: 24px !important;
    height: 24px !important;
    min-width: 24px !important;
    min-height: 24px !important;
  }
  
  .remove-card-btn .n-icon {
    font-size: 12px !important;
  }
}
</style>
